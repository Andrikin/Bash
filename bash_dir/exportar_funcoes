#!/usr/bin/env bash

# Estas funções estão restritas ao uso no terminal. Funções aqui descritas não irão funcionar em scripts
# TODO: Make a readline function to map characters to make a soft capslock

# Nnn file manager
nnncd(){
	nnn -e "$@"
	if [[ -f $NNN_TMPFILE ]];then
		. "$NNN_TMPFILE"
		rm -f "$NNN_TMPFILE" > /dev/null
	fi
	clear
}

# Lf file manager
lfcd(){
   tmp="$(mktemp)"
   lf -last-dir-path="$tmp" "$@"
   if [ -f "$tmp" ]; then
       dir="$(grep --color=never . "$tmp")"
       rm -f "$tmp"
       if [ -d "$dir" ]; then
           if [ "$dir" != "$(pwd)" ]; then
               cd "$dir"
           fi
       fi
   fi
   clear
}

# Fff file manager
fffcd(){
   fff "$@"
   endereco="$(< "${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d")"
   if [[ $endereco != $PWD ]];then
       cd "$endereco"
   fi
   clear
}

# Utilizar no lugar de sleep
snore(){
	# Usage: snore 1
    #        snore 0.2
    read -rt "$1" <> <(true) || true
}

# $1=FILE; $2=COMMIT_MESSAGE
git_push_file(){
	git add "$1" && git commit -m "$2" && git push -u origin "$(__git_ps1 '%s')"
}

nv(){
	nvim "$@"
	clear
}

# [a-z] to [A-Z]
soft_capslock_on(){
	for n in {97..122}
	do
		hex_c_lower="$(printf '\\x%x' $((n)))"
		hex_c_upper="$(printf '\\x%x' $((n-32)))"
		bind -m vi-insert $"\"$hex_c_lower\": \"$hex_c_upper\""
	done
	SOFT_CAPSLOCK=1
}

soft_capslock_off(){
	for n in {97..122}
	do
		hex_c_lower="$(printf '\\x%x' $((n)))"
		bind -m vi-insert $"\"$hex_c_lower\": self-insert"
	done
	SOFT_CAPSLOCK=0
}

# Bind: bind -m vi-insert $'"\xhh": "\xhh"'
# Revert bind with: bind -m vi-insert '"\xhh": self-insert'
soft_capslock_toggle(){
	if (( !$SOFT_CAPSLOCK ))
	then
		soft_capslock_on
	else
		soft_capslock_off
	fi
}

# __capslock_statusline(){
# 	local caps=''
# 	if (( $SOFT_CAPSLOCK ))
# 	then
# 		caps='[CAPS]'
# 	fi
# 	echo "$caps"
# }

__prompt_command(){
	# Reset soft capslock
	if (( $SOFT_CAPSLOCK ))
	then
		soft_capslock_off
	fi
	# \u - user, \w - diretório
	# Sempre lembrar de envolver comandos não printáveis com "\[\]"
	# Cores
	local PS1_BG_CINZA='\[\e[48;5;239m\]'
	local PS1_FG_CINZA='\[\e[38;5;239m\]'
	local PS1_BG_BRANCO='\[\e[107m\]'
	local PS1_FG_BRANCO='\[\e[39m\]'
	local PS1_FG_VERMELHO='\[\e[31m\]'
	local PS1_FONTE_BOLD='\[\e[1m\]'
	local PS1_RESET_COR='\[\e[0m\]'
	PS1="${PS1_RESET_COR}${PS1_FONTE_BOLD}${PS1_BG_CINZA} Andre ${PS1_FG_CINZA}${PS1_BG_BRANCO}${PS1_RESET_COR}${PS1_FONTE_BOLD}${PS1_FG_CINZA}${PS1_BG_BRANCO} \W${PS1_FG_VERMELHO}\$(__git_ps1 ' [%s]')${PS1_RESET_COR}${PS1_FG_BRANCO}${PS1_RESET_COR}"
}

# Complete quote
readline_complete_it(){
	READLINE_LINE="${READLINE_LINE:0:$READLINE_POINT}$1${READLINE_LINE:$READLINE_POINT}"
	# Get cursor on right place
	((READLINE_POINT+=1))
}

# Single quotes
# -m mode; -x shell-functions
bind -m vi-command -x '"\C-k": nnncd'
bind -m vi-insert -x '"\C-k": nnncd'
bind -m vi-insert -x '"\C-l": soft_capslock_toggle'
bind -m vi-insert -x $'"\x27\x27": readline_complete_it \\\x27\\\x27' # single quote
bind -m vi-insert -x $'"\\\x22\\\x22": readline_complete_it \\\x22\\\x22' # double quote

#tabbed_st(){
#	TABBED_GUIA="$HOME/.local/share/tabbed_guia.num"
#	tabbed -c -r 2 st -w '' -T "Guia $(($(< $TABBED_GUIA)++))"
#}
